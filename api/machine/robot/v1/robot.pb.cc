// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: v1/robot.proto

#include "v1/robot.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace machine {
namespace robot {
namespace v1 {
constexpr AppendCoordinateRequest::AppendCoordinateRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : uuid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , check_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , x_(0)
  , y_(0)
  , z_(0)
  , rx_(0)
  , ry_(0)
  , delay_(0)
  , check_(false){}
struct AppendCoordinateRequestDefaultTypeInternal {
  constexpr AppendCoordinateRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AppendCoordinateRequestDefaultTypeInternal() {}
  union {
    AppendCoordinateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AppendCoordinateRequestDefaultTypeInternal _AppendCoordinateRequest_default_instance_;
constexpr AppendCoordinateReply::AppendCoordinateReply(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : status_(false){}
struct AppendCoordinateReplyDefaultTypeInternal {
  constexpr AppendCoordinateReplyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AppendCoordinateReplyDefaultTypeInternal() {}
  union {
    AppendCoordinateReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AppendCoordinateReplyDefaultTypeInternal _AppendCoordinateReply_default_instance_;
constexpr ZeroRequest::ZeroRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : zero_(false){}
struct ZeroRequestDefaultTypeInternal {
  constexpr ZeroRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ZeroRequestDefaultTypeInternal() {}
  union {
    ZeroRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ZeroRequestDefaultTypeInternal _ZeroRequest_default_instance_;
constexpr ZeroReply::ZeroReply(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : status_(false){}
struct ZeroReplyDefaultTypeInternal {
  constexpr ZeroReplyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ZeroReplyDefaultTypeInternal() {}
  union {
    ZeroReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ZeroReplyDefaultTypeInternal _ZeroReply_default_instance_;
constexpr GetMotorInfoRequest::GetMotorInfoRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : status_(false){}
struct GetMotorInfoRequestDefaultTypeInternal {
  constexpr GetMotorInfoRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetMotorInfoRequestDefaultTypeInternal() {}
  union {
    GetMotorInfoRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetMotorInfoRequestDefaultTypeInternal _GetMotorInfoRequest_default_instance_;
constexpr GetMotorInfoReply::GetMotorInfoReply(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : motor_info_(){}
struct GetMotorInfoReplyDefaultTypeInternal {
  constexpr GetMotorInfoReplyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetMotorInfoReplyDefaultTypeInternal() {}
  union {
    GetMotorInfoReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetMotorInfoReplyDefaultTypeInternal _GetMotorInfoReply_default_instance_;
constexpr MotorInfo::MotorInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : motor_status_(nullptr)
  , instr_pos_(int64_t{0})
  , current_pos_(int64_t{0}){}
struct MotorInfoDefaultTypeInternal {
  constexpr MotorInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MotorInfoDefaultTypeInternal() {}
  union {
    MotorInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MotorInfoDefaultTypeInternal _MotorInfo_default_instance_;
constexpr MotorStatus::MotorStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : fault_(false)
  , enabling_(false)
  , running_(false)
  , instruction_completion_(false)
  , path_completion_(false)
  , zero_completion_(false){}
struct MotorStatusDefaultTypeInternal {
  constexpr MotorStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MotorStatusDefaultTypeInternal() {}
  union {
    MotorStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MotorStatusDefaultTypeInternal _MotorStatus_default_instance_;
}  // namespace v1
}  // namespace robot
}  // namespace machine
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_v1_2frobot_2eproto[8];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_v1_2frobot_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_v1_2frobot_2eproto = nullptr;

const uint32_t TableStruct_v1_2frobot_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::AppendCoordinateRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::AppendCoordinateRequest, x_),
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::AppendCoordinateRequest, y_),
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::AppendCoordinateRequest, z_),
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::AppendCoordinateRequest, rx_),
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::AppendCoordinateRequest, ry_),
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::AppendCoordinateRequest, check_),
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::AppendCoordinateRequest, delay_),
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::AppendCoordinateRequest, uuid_),
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::AppendCoordinateRequest, check_name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::AppendCoordinateReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::AppendCoordinateReply, status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::ZeroRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::ZeroRequest, zero_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::ZeroReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::ZeroReply, status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::GetMotorInfoRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::GetMotorInfoRequest, status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::GetMotorInfoReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::GetMotorInfoReply, motor_info_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::MotorInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::MotorInfo, motor_status_),
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::MotorInfo, instr_pos_),
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::MotorInfo, current_pos_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::MotorStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::MotorStatus, fault_),
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::MotorStatus, enabling_),
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::MotorStatus, running_),
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::MotorStatus, instruction_completion_),
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::MotorStatus, path_completion_),
  PROTOBUF_FIELD_OFFSET(::machine::robot::v1::MotorStatus, zero_completion_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::machine::robot::v1::AppendCoordinateRequest)},
  { 15, -1, -1, sizeof(::machine::robot::v1::AppendCoordinateReply)},
  { 22, -1, -1, sizeof(::machine::robot::v1::ZeroRequest)},
  { 29, -1, -1, sizeof(::machine::robot::v1::ZeroReply)},
  { 36, -1, -1, sizeof(::machine::robot::v1::GetMotorInfoRequest)},
  { 43, -1, -1, sizeof(::machine::robot::v1::GetMotorInfoReply)},
  { 50, -1, -1, sizeof(::machine::robot::v1::MotorInfo)},
  { 59, -1, -1, sizeof(::machine::robot::v1::MotorStatus)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::machine::robot::v1::_AppendCoordinateRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::machine::robot::v1::_AppendCoordinateReply_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::machine::robot::v1::_ZeroRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::machine::robot::v1::_ZeroReply_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::machine::robot::v1::_GetMotorInfoRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::machine::robot::v1::_GetMotorInfoReply_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::machine::robot::v1::_MotorInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::machine::robot::v1::_MotorStatus_default_instance_),
};

const char descriptor_table_protodef_v1_2frobot_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\016v1/robot.proto\022\020machine.robot.v1\"\222\001\n\027A"
  "ppendCoordinateRequest\022\t\n\001x\030\001 \001(\001\022\t\n\001y\030\002"
  " \001(\001\022\t\n\001z\030\003 \001(\001\022\n\n\002rx\030\004 \001(\001\022\n\n\002ry\030\005 \001(\001\022"
  "\r\n\005check\030\006 \001(\010\022\r\n\005delay\030\007 \001(\001\022\014\n\004uuid\030\010 "
  "\001(\t\022\022\n\ncheck_name\030\t \001(\t\"\'\n\025AppendCoordin"
  "ateReply\022\016\n\006status\030\001 \001(\010\"\033\n\013ZeroRequest\022"
  "\014\n\004zero\030\001 \001(\010\"\033\n\tZeroReply\022\016\n\006status\030\001 \001"
  "(\010\"%\n\023GetMotorInfoRequest\022\016\n\006status\030\001 \001("
  "\010\"D\n\021GetMotorInfoReply\022/\n\nmotor_info\030\001 \003"
  "(\0132\033.machine.robot.v1.MotorInfo\"h\n\tMotor"
  "Info\0223\n\014motor_status\030\001 \001(\0132\035.machine.rob"
  "ot.v1.MotorStatus\022\021\n\tinstr_pos\030\002 \001(\003\022\023\n\013"
  "current_pos\030\003 \001(\003\"\221\001\n\013MotorStatus\022\r\n\005fau"
  "lt\030\001 \001(\010\022\020\n\010enabling\030\002 \001(\010\022\017\n\007running\030\003 "
  "\001(\010\022\036\n\026instruction_completion\030\004 \001(\010\022\027\n\017p"
  "ath_completion\030\005 \001(\010\022\027\n\017zero_completion\030"
  "\006 \001(\0102\227\002\n\007Control\022h\n\020AppendCoordinate\022)."
  "machine.robot.v1.AppendCoordinateRequest"
  "\032\'.machine.robot.v1.AppendCoordinateRepl"
  "y\"\000\022D\n\004Zero\022\035.machine.robot.v1.ZeroReque"
  "st\032\033.machine.robot.v1.ZeroReply\"\000\022\\\n\014Get"
  "MotorInfo\022%.machine.robot.v1.GetMotorInf"
  "oRequest\032#.machine.robot.v1.GetMotorInfo"
  "Reply\"\000B\031Z\027api/machine/robot/v1;v1b\006prot"
  "o3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_v1_2frobot_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_v1_2frobot_2eproto = {
  false, false, 962, descriptor_table_protodef_v1_2frobot_2eproto, "v1/robot.proto", 
  &descriptor_table_v1_2frobot_2eproto_once, nullptr, 0, 8,
  schemas, file_default_instances, TableStruct_v1_2frobot_2eproto::offsets,
  file_level_metadata_v1_2frobot_2eproto, file_level_enum_descriptors_v1_2frobot_2eproto, file_level_service_descriptors_v1_2frobot_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_v1_2frobot_2eproto_getter() {
  return &descriptor_table_v1_2frobot_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_v1_2frobot_2eproto(&descriptor_table_v1_2frobot_2eproto);
namespace machine {
namespace robot {
namespace v1 {

// ===================================================================

class AppendCoordinateRequest::_Internal {
 public:
};

AppendCoordinateRequest::AppendCoordinateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:machine.robot.v1.AppendCoordinateRequest)
}
AppendCoordinateRequest::AppendCoordinateRequest(const AppendCoordinateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  uuid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_uuid().empty()) {
    uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_uuid(), 
      GetArenaForAllocation());
  }
  check_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    check_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_check_name().empty()) {
    check_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_check_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&check_) -
    reinterpret_cast<char*>(&x_)) + sizeof(check_));
  // @@protoc_insertion_point(copy_constructor:machine.robot.v1.AppendCoordinateRequest)
}

inline void AppendCoordinateRequest::SharedCtor() {
uuid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
check_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  check_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&x_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&check_) -
    reinterpret_cast<char*>(&x_)) + sizeof(check_));
}

AppendCoordinateRequest::~AppendCoordinateRequest() {
  // @@protoc_insertion_point(destructor:machine.robot.v1.AppendCoordinateRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AppendCoordinateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  uuid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  check_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AppendCoordinateRequest::ArenaDtor(void* object) {
  AppendCoordinateRequest* _this = reinterpret_cast< AppendCoordinateRequest* >(object);
  (void)_this;
}
void AppendCoordinateRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AppendCoordinateRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AppendCoordinateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:machine.robot.v1.AppendCoordinateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  uuid_.ClearToEmpty();
  check_name_.ClearToEmpty();
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&check_) -
      reinterpret_cast<char*>(&x_)) + sizeof(check_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AppendCoordinateRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double rx = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          rx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double ry = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          ry_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // bool check = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          check_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double delay = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          delay_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // string uuid = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_uuid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "machine.robot.v1.AppendCoordinateRequest.uuid"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string check_name = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_check_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "machine.robot.v1.AppendCoordinateRequest.check_name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AppendCoordinateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:machine.robot.v1.AppendCoordinateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double x = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_x(), target);
  }

  // double y = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  // double z = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_z(), target);
  }

  // double rx = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rx = this->_internal_rx();
  uint64_t raw_rx;
  memcpy(&raw_rx, &tmp_rx, sizeof(tmp_rx));
  if (raw_rx != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_rx(), target);
  }

  // double ry = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_ry = this->_internal_ry();
  uint64_t raw_ry;
  memcpy(&raw_ry, &tmp_ry, sizeof(tmp_ry));
  if (raw_ry != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_ry(), target);
  }

  // bool check = 6;
  if (this->_internal_check() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_check(), target);
  }

  // double delay = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_delay = this->_internal_delay();
  uint64_t raw_delay;
  memcpy(&raw_delay, &tmp_delay, sizeof(tmp_delay));
  if (raw_delay != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(7, this->_internal_delay(), target);
  }

  // string uuid = 8;
  if (!this->_internal_uuid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_uuid().data(), static_cast<int>(this->_internal_uuid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "machine.robot.v1.AppendCoordinateRequest.uuid");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_uuid(), target);
  }

  // string check_name = 9;
  if (!this->_internal_check_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_check_name().data(), static_cast<int>(this->_internal_check_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "machine.robot.v1.AppendCoordinateRequest.check_name");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_check_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:machine.robot.v1.AppendCoordinateRequest)
  return target;
}

size_t AppendCoordinateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:machine.robot.v1.AppendCoordinateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string uuid = 8;
  if (!this->_internal_uuid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_uuid());
  }

  // string check_name = 9;
  if (!this->_internal_check_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_check_name());
  }

  // double x = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 8;
  }

  // double y = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 8;
  }

  // double z = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 8;
  }

  // double rx = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rx = this->_internal_rx();
  uint64_t raw_rx;
  memcpy(&raw_rx, &tmp_rx, sizeof(tmp_rx));
  if (raw_rx != 0) {
    total_size += 1 + 8;
  }

  // double ry = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_ry = this->_internal_ry();
  uint64_t raw_ry;
  memcpy(&raw_ry, &tmp_ry, sizeof(tmp_ry));
  if (raw_ry != 0) {
    total_size += 1 + 8;
  }

  // double delay = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_delay = this->_internal_delay();
  uint64_t raw_delay;
  memcpy(&raw_delay, &tmp_delay, sizeof(tmp_delay));
  if (raw_delay != 0) {
    total_size += 1 + 8;
  }

  // bool check = 6;
  if (this->_internal_check() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AppendCoordinateRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AppendCoordinateRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AppendCoordinateRequest::GetClassData() const { return &_class_data_; }

void AppendCoordinateRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AppendCoordinateRequest *>(to)->MergeFrom(
      static_cast<const AppendCoordinateRequest &>(from));
}


void AppendCoordinateRequest::MergeFrom(const AppendCoordinateRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:machine.robot.v1.AppendCoordinateRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_uuid().empty()) {
    _internal_set_uuid(from._internal_uuid());
  }
  if (!from._internal_check_name().empty()) {
    _internal_set_check_name(from._internal_check_name());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = from._internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = from._internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = from._internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _internal_set_z(from._internal_z());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rx = from._internal_rx();
  uint64_t raw_rx;
  memcpy(&raw_rx, &tmp_rx, sizeof(tmp_rx));
  if (raw_rx != 0) {
    _internal_set_rx(from._internal_rx());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_ry = from._internal_ry();
  uint64_t raw_ry;
  memcpy(&raw_ry, &tmp_ry, sizeof(tmp_ry));
  if (raw_ry != 0) {
    _internal_set_ry(from._internal_ry());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_delay = from._internal_delay();
  uint64_t raw_delay;
  memcpy(&raw_delay, &tmp_delay, sizeof(tmp_delay));
  if (raw_delay != 0) {
    _internal_set_delay(from._internal_delay());
  }
  if (from._internal_check() != 0) {
    _internal_set_check(from._internal_check());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AppendCoordinateRequest::CopyFrom(const AppendCoordinateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:machine.robot.v1.AppendCoordinateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AppendCoordinateRequest::IsInitialized() const {
  return true;
}

void AppendCoordinateRequest::InternalSwap(AppendCoordinateRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &uuid_, lhs_arena,
      &other->uuid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &check_name_, lhs_arena,
      &other->check_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AppendCoordinateRequest, check_)
      + sizeof(AppendCoordinateRequest::check_)
      - PROTOBUF_FIELD_OFFSET(AppendCoordinateRequest, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AppendCoordinateRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_v1_2frobot_2eproto_getter, &descriptor_table_v1_2frobot_2eproto_once,
      file_level_metadata_v1_2frobot_2eproto[0]);
}

// ===================================================================

class AppendCoordinateReply::_Internal {
 public:
};

AppendCoordinateReply::AppendCoordinateReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:machine.robot.v1.AppendCoordinateReply)
}
AppendCoordinateReply::AppendCoordinateReply(const AppendCoordinateReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  status_ = from.status_;
  // @@protoc_insertion_point(copy_constructor:machine.robot.v1.AppendCoordinateReply)
}

inline void AppendCoordinateReply::SharedCtor() {
status_ = false;
}

AppendCoordinateReply::~AppendCoordinateReply() {
  // @@protoc_insertion_point(destructor:machine.robot.v1.AppendCoordinateReply)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AppendCoordinateReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AppendCoordinateReply::ArenaDtor(void* object) {
  AppendCoordinateReply* _this = reinterpret_cast< AppendCoordinateReply* >(object);
  (void)_this;
}
void AppendCoordinateReply::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AppendCoordinateReply::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AppendCoordinateReply::Clear() {
// @@protoc_insertion_point(message_clear_start:machine.robot.v1.AppendCoordinateReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  status_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AppendCoordinateReply::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AppendCoordinateReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:machine.robot.v1.AppendCoordinateReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool status = 1;
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:machine.robot.v1.AppendCoordinateReply)
  return target;
}

size_t AppendCoordinateReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:machine.robot.v1.AppendCoordinateReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool status = 1;
  if (this->_internal_status() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AppendCoordinateReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AppendCoordinateReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AppendCoordinateReply::GetClassData() const { return &_class_data_; }

void AppendCoordinateReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AppendCoordinateReply *>(to)->MergeFrom(
      static_cast<const AppendCoordinateReply &>(from));
}


void AppendCoordinateReply::MergeFrom(const AppendCoordinateReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:machine.robot.v1.AppendCoordinateReply)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_status() != 0) {
    _internal_set_status(from._internal_status());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AppendCoordinateReply::CopyFrom(const AppendCoordinateReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:machine.robot.v1.AppendCoordinateReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AppendCoordinateReply::IsInitialized() const {
  return true;
}

void AppendCoordinateReply::InternalSwap(AppendCoordinateReply* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(status_, other->status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AppendCoordinateReply::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_v1_2frobot_2eproto_getter, &descriptor_table_v1_2frobot_2eproto_once,
      file_level_metadata_v1_2frobot_2eproto[1]);
}

// ===================================================================

class ZeroRequest::_Internal {
 public:
};

ZeroRequest::ZeroRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:machine.robot.v1.ZeroRequest)
}
ZeroRequest::ZeroRequest(const ZeroRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  zero_ = from.zero_;
  // @@protoc_insertion_point(copy_constructor:machine.robot.v1.ZeroRequest)
}

inline void ZeroRequest::SharedCtor() {
zero_ = false;
}

ZeroRequest::~ZeroRequest() {
  // @@protoc_insertion_point(destructor:machine.robot.v1.ZeroRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ZeroRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ZeroRequest::ArenaDtor(void* object) {
  ZeroRequest* _this = reinterpret_cast< ZeroRequest* >(object);
  (void)_this;
}
void ZeroRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ZeroRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ZeroRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:machine.robot.v1.ZeroRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  zero_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ZeroRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool zero = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          zero_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ZeroRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:machine.robot.v1.ZeroRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool zero = 1;
  if (this->_internal_zero() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_zero(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:machine.robot.v1.ZeroRequest)
  return target;
}

size_t ZeroRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:machine.robot.v1.ZeroRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool zero = 1;
  if (this->_internal_zero() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ZeroRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ZeroRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ZeroRequest::GetClassData() const { return &_class_data_; }

void ZeroRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ZeroRequest *>(to)->MergeFrom(
      static_cast<const ZeroRequest &>(from));
}


void ZeroRequest::MergeFrom(const ZeroRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:machine.robot.v1.ZeroRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_zero() != 0) {
    _internal_set_zero(from._internal_zero());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ZeroRequest::CopyFrom(const ZeroRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:machine.robot.v1.ZeroRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ZeroRequest::IsInitialized() const {
  return true;
}

void ZeroRequest::InternalSwap(ZeroRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(zero_, other->zero_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ZeroRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_v1_2frobot_2eproto_getter, &descriptor_table_v1_2frobot_2eproto_once,
      file_level_metadata_v1_2frobot_2eproto[2]);
}

// ===================================================================

class ZeroReply::_Internal {
 public:
};

ZeroReply::ZeroReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:machine.robot.v1.ZeroReply)
}
ZeroReply::ZeroReply(const ZeroReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  status_ = from.status_;
  // @@protoc_insertion_point(copy_constructor:machine.robot.v1.ZeroReply)
}

inline void ZeroReply::SharedCtor() {
status_ = false;
}

ZeroReply::~ZeroReply() {
  // @@protoc_insertion_point(destructor:machine.robot.v1.ZeroReply)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ZeroReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ZeroReply::ArenaDtor(void* object) {
  ZeroReply* _this = reinterpret_cast< ZeroReply* >(object);
  (void)_this;
}
void ZeroReply::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ZeroReply::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ZeroReply::Clear() {
// @@protoc_insertion_point(message_clear_start:machine.robot.v1.ZeroReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  status_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ZeroReply::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ZeroReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:machine.robot.v1.ZeroReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool status = 1;
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:machine.robot.v1.ZeroReply)
  return target;
}

size_t ZeroReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:machine.robot.v1.ZeroReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool status = 1;
  if (this->_internal_status() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ZeroReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ZeroReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ZeroReply::GetClassData() const { return &_class_data_; }

void ZeroReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ZeroReply *>(to)->MergeFrom(
      static_cast<const ZeroReply &>(from));
}


void ZeroReply::MergeFrom(const ZeroReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:machine.robot.v1.ZeroReply)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_status() != 0) {
    _internal_set_status(from._internal_status());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ZeroReply::CopyFrom(const ZeroReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:machine.robot.v1.ZeroReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ZeroReply::IsInitialized() const {
  return true;
}

void ZeroReply::InternalSwap(ZeroReply* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(status_, other->status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ZeroReply::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_v1_2frobot_2eproto_getter, &descriptor_table_v1_2frobot_2eproto_once,
      file_level_metadata_v1_2frobot_2eproto[3]);
}

// ===================================================================

class GetMotorInfoRequest::_Internal {
 public:
};

GetMotorInfoRequest::GetMotorInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:machine.robot.v1.GetMotorInfoRequest)
}
GetMotorInfoRequest::GetMotorInfoRequest(const GetMotorInfoRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  status_ = from.status_;
  // @@protoc_insertion_point(copy_constructor:machine.robot.v1.GetMotorInfoRequest)
}

inline void GetMotorInfoRequest::SharedCtor() {
status_ = false;
}

GetMotorInfoRequest::~GetMotorInfoRequest() {
  // @@protoc_insertion_point(destructor:machine.robot.v1.GetMotorInfoRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetMotorInfoRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GetMotorInfoRequest::ArenaDtor(void* object) {
  GetMotorInfoRequest* _this = reinterpret_cast< GetMotorInfoRequest* >(object);
  (void)_this;
}
void GetMotorInfoRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetMotorInfoRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetMotorInfoRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:machine.robot.v1.GetMotorInfoRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  status_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetMotorInfoRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetMotorInfoRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:machine.robot.v1.GetMotorInfoRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool status = 1;
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:machine.robot.v1.GetMotorInfoRequest)
  return target;
}

size_t GetMotorInfoRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:machine.robot.v1.GetMotorInfoRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool status = 1;
  if (this->_internal_status() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetMotorInfoRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetMotorInfoRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetMotorInfoRequest::GetClassData() const { return &_class_data_; }

void GetMotorInfoRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetMotorInfoRequest *>(to)->MergeFrom(
      static_cast<const GetMotorInfoRequest &>(from));
}


void GetMotorInfoRequest::MergeFrom(const GetMotorInfoRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:machine.robot.v1.GetMotorInfoRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_status() != 0) {
    _internal_set_status(from._internal_status());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetMotorInfoRequest::CopyFrom(const GetMotorInfoRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:machine.robot.v1.GetMotorInfoRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetMotorInfoRequest::IsInitialized() const {
  return true;
}

void GetMotorInfoRequest::InternalSwap(GetMotorInfoRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(status_, other->status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetMotorInfoRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_v1_2frobot_2eproto_getter, &descriptor_table_v1_2frobot_2eproto_once,
      file_level_metadata_v1_2frobot_2eproto[4]);
}

// ===================================================================

class GetMotorInfoReply::_Internal {
 public:
};

GetMotorInfoReply::GetMotorInfoReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  motor_info_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:machine.robot.v1.GetMotorInfoReply)
}
GetMotorInfoReply::GetMotorInfoReply(const GetMotorInfoReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      motor_info_(from.motor_info_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:machine.robot.v1.GetMotorInfoReply)
}

inline void GetMotorInfoReply::SharedCtor() {
}

GetMotorInfoReply::~GetMotorInfoReply() {
  // @@protoc_insertion_point(destructor:machine.robot.v1.GetMotorInfoReply)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetMotorInfoReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GetMotorInfoReply::ArenaDtor(void* object) {
  GetMotorInfoReply* _this = reinterpret_cast< GetMotorInfoReply* >(object);
  (void)_this;
}
void GetMotorInfoReply::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetMotorInfoReply::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetMotorInfoReply::Clear() {
// @@protoc_insertion_point(message_clear_start:machine.robot.v1.GetMotorInfoReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  motor_info_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetMotorInfoReply::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .machine.robot.v1.MotorInfo motor_info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_motor_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetMotorInfoReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:machine.robot.v1.GetMotorInfoReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .machine.robot.v1.MotorInfo motor_info = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_motor_info_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_motor_info(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:machine.robot.v1.GetMotorInfoReply)
  return target;
}

size_t GetMotorInfoReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:machine.robot.v1.GetMotorInfoReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .machine.robot.v1.MotorInfo motor_info = 1;
  total_size += 1UL * this->_internal_motor_info_size();
  for (const auto& msg : this->motor_info_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetMotorInfoReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetMotorInfoReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetMotorInfoReply::GetClassData() const { return &_class_data_; }

void GetMotorInfoReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetMotorInfoReply *>(to)->MergeFrom(
      static_cast<const GetMotorInfoReply &>(from));
}


void GetMotorInfoReply::MergeFrom(const GetMotorInfoReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:machine.robot.v1.GetMotorInfoReply)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  motor_info_.MergeFrom(from.motor_info_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetMotorInfoReply::CopyFrom(const GetMotorInfoReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:machine.robot.v1.GetMotorInfoReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetMotorInfoReply::IsInitialized() const {
  return true;
}

void GetMotorInfoReply::InternalSwap(GetMotorInfoReply* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  motor_info_.InternalSwap(&other->motor_info_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetMotorInfoReply::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_v1_2frobot_2eproto_getter, &descriptor_table_v1_2frobot_2eproto_once,
      file_level_metadata_v1_2frobot_2eproto[5]);
}

// ===================================================================

class MotorInfo::_Internal {
 public:
  static const ::machine::robot::v1::MotorStatus& motor_status(const MotorInfo* msg);
};

const ::machine::robot::v1::MotorStatus&
MotorInfo::_Internal::motor_status(const MotorInfo* msg) {
  return *msg->motor_status_;
}
MotorInfo::MotorInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:machine.robot.v1.MotorInfo)
}
MotorInfo::MotorInfo(const MotorInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_motor_status()) {
    motor_status_ = new ::machine::robot::v1::MotorStatus(*from.motor_status_);
  } else {
    motor_status_ = nullptr;
  }
  ::memcpy(&instr_pos_, &from.instr_pos_,
    static_cast<size_t>(reinterpret_cast<char*>(&current_pos_) -
    reinterpret_cast<char*>(&instr_pos_)) + sizeof(current_pos_));
  // @@protoc_insertion_point(copy_constructor:machine.robot.v1.MotorInfo)
}

inline void MotorInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&motor_status_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&current_pos_) -
    reinterpret_cast<char*>(&motor_status_)) + sizeof(current_pos_));
}

MotorInfo::~MotorInfo() {
  // @@protoc_insertion_point(destructor:machine.robot.v1.MotorInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MotorInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete motor_status_;
}

void MotorInfo::ArenaDtor(void* object) {
  MotorInfo* _this = reinterpret_cast< MotorInfo* >(object);
  (void)_this;
}
void MotorInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MotorInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MotorInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:machine.robot.v1.MotorInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && motor_status_ != nullptr) {
    delete motor_status_;
  }
  motor_status_ = nullptr;
  ::memset(&instr_pos_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&current_pos_) -
      reinterpret_cast<char*>(&instr_pos_)) + sizeof(current_pos_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MotorInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .machine.robot.v1.MotorStatus motor_status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_motor_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 instr_pos = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          instr_pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 current_pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          current_pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MotorInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:machine.robot.v1.MotorInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .machine.robot.v1.MotorStatus motor_status = 1;
  if (this->_internal_has_motor_status()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::motor_status(this), target, stream);
  }

  // int64 instr_pos = 2;
  if (this->_internal_instr_pos() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_instr_pos(), target);
  }

  // int64 current_pos = 3;
  if (this->_internal_current_pos() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_current_pos(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:machine.robot.v1.MotorInfo)
  return target;
}

size_t MotorInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:machine.robot.v1.MotorInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .machine.robot.v1.MotorStatus motor_status = 1;
  if (this->_internal_has_motor_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *motor_status_);
  }

  // int64 instr_pos = 2;
  if (this->_internal_instr_pos() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_instr_pos());
  }

  // int64 current_pos = 3;
  if (this->_internal_current_pos() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_current_pos());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MotorInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MotorInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MotorInfo::GetClassData() const { return &_class_data_; }

void MotorInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MotorInfo *>(to)->MergeFrom(
      static_cast<const MotorInfo &>(from));
}


void MotorInfo::MergeFrom(const MotorInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:machine.robot.v1.MotorInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_motor_status()) {
    _internal_mutable_motor_status()->::machine::robot::v1::MotorStatus::MergeFrom(from._internal_motor_status());
  }
  if (from._internal_instr_pos() != 0) {
    _internal_set_instr_pos(from._internal_instr_pos());
  }
  if (from._internal_current_pos() != 0) {
    _internal_set_current_pos(from._internal_current_pos());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MotorInfo::CopyFrom(const MotorInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:machine.robot.v1.MotorInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MotorInfo::IsInitialized() const {
  return true;
}

void MotorInfo::InternalSwap(MotorInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MotorInfo, current_pos_)
      + sizeof(MotorInfo::current_pos_)
      - PROTOBUF_FIELD_OFFSET(MotorInfo, motor_status_)>(
          reinterpret_cast<char*>(&motor_status_),
          reinterpret_cast<char*>(&other->motor_status_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MotorInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_v1_2frobot_2eproto_getter, &descriptor_table_v1_2frobot_2eproto_once,
      file_level_metadata_v1_2frobot_2eproto[6]);
}

// ===================================================================

class MotorStatus::_Internal {
 public:
};

MotorStatus::MotorStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:machine.robot.v1.MotorStatus)
}
MotorStatus::MotorStatus(const MotorStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&fault_, &from.fault_,
    static_cast<size_t>(reinterpret_cast<char*>(&zero_completion_) -
    reinterpret_cast<char*>(&fault_)) + sizeof(zero_completion_));
  // @@protoc_insertion_point(copy_constructor:machine.robot.v1.MotorStatus)
}

inline void MotorStatus::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&fault_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&zero_completion_) -
    reinterpret_cast<char*>(&fault_)) + sizeof(zero_completion_));
}

MotorStatus::~MotorStatus() {
  // @@protoc_insertion_point(destructor:machine.robot.v1.MotorStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MotorStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MotorStatus::ArenaDtor(void* object) {
  MotorStatus* _this = reinterpret_cast< MotorStatus* >(object);
  (void)_this;
}
void MotorStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MotorStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MotorStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:machine.robot.v1.MotorStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&fault_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&zero_completion_) -
      reinterpret_cast<char*>(&fault_)) + sizeof(zero_completion_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MotorStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool fault = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          fault_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool enabling = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          enabling_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool running = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          running_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool instruction_completion = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          instruction_completion_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool path_completion = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          path_completion_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool zero_completion = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          zero_completion_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MotorStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:machine.robot.v1.MotorStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool fault = 1;
  if (this->_internal_fault() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_fault(), target);
  }

  // bool enabling = 2;
  if (this->_internal_enabling() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_enabling(), target);
  }

  // bool running = 3;
  if (this->_internal_running() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_running(), target);
  }

  // bool instruction_completion = 4;
  if (this->_internal_instruction_completion() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_instruction_completion(), target);
  }

  // bool path_completion = 5;
  if (this->_internal_path_completion() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_path_completion(), target);
  }

  // bool zero_completion = 6;
  if (this->_internal_zero_completion() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_zero_completion(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:machine.robot.v1.MotorStatus)
  return target;
}

size_t MotorStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:machine.robot.v1.MotorStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool fault = 1;
  if (this->_internal_fault() != 0) {
    total_size += 1 + 1;
  }

  // bool enabling = 2;
  if (this->_internal_enabling() != 0) {
    total_size += 1 + 1;
  }

  // bool running = 3;
  if (this->_internal_running() != 0) {
    total_size += 1 + 1;
  }

  // bool instruction_completion = 4;
  if (this->_internal_instruction_completion() != 0) {
    total_size += 1 + 1;
  }

  // bool path_completion = 5;
  if (this->_internal_path_completion() != 0) {
    total_size += 1 + 1;
  }

  // bool zero_completion = 6;
  if (this->_internal_zero_completion() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MotorStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MotorStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MotorStatus::GetClassData() const { return &_class_data_; }

void MotorStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MotorStatus *>(to)->MergeFrom(
      static_cast<const MotorStatus &>(from));
}


void MotorStatus::MergeFrom(const MotorStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:machine.robot.v1.MotorStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_fault() != 0) {
    _internal_set_fault(from._internal_fault());
  }
  if (from._internal_enabling() != 0) {
    _internal_set_enabling(from._internal_enabling());
  }
  if (from._internal_running() != 0) {
    _internal_set_running(from._internal_running());
  }
  if (from._internal_instruction_completion() != 0) {
    _internal_set_instruction_completion(from._internal_instruction_completion());
  }
  if (from._internal_path_completion() != 0) {
    _internal_set_path_completion(from._internal_path_completion());
  }
  if (from._internal_zero_completion() != 0) {
    _internal_set_zero_completion(from._internal_zero_completion());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MotorStatus::CopyFrom(const MotorStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:machine.robot.v1.MotorStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MotorStatus::IsInitialized() const {
  return true;
}

void MotorStatus::InternalSwap(MotorStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MotorStatus, zero_completion_)
      + sizeof(MotorStatus::zero_completion_)
      - PROTOBUF_FIELD_OFFSET(MotorStatus, fault_)>(
          reinterpret_cast<char*>(&fault_),
          reinterpret_cast<char*>(&other->fault_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MotorStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_v1_2frobot_2eproto_getter, &descriptor_table_v1_2frobot_2eproto_once,
      file_level_metadata_v1_2frobot_2eproto[7]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace robot
}  // namespace machine
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::machine::robot::v1::AppendCoordinateRequest* Arena::CreateMaybeMessage< ::machine::robot::v1::AppendCoordinateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::machine::robot::v1::AppendCoordinateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::machine::robot::v1::AppendCoordinateReply* Arena::CreateMaybeMessage< ::machine::robot::v1::AppendCoordinateReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::machine::robot::v1::AppendCoordinateReply >(arena);
}
template<> PROTOBUF_NOINLINE ::machine::robot::v1::ZeroRequest* Arena::CreateMaybeMessage< ::machine::robot::v1::ZeroRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::machine::robot::v1::ZeroRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::machine::robot::v1::ZeroReply* Arena::CreateMaybeMessage< ::machine::robot::v1::ZeroReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::machine::robot::v1::ZeroReply >(arena);
}
template<> PROTOBUF_NOINLINE ::machine::robot::v1::GetMotorInfoRequest* Arena::CreateMaybeMessage< ::machine::robot::v1::GetMotorInfoRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::machine::robot::v1::GetMotorInfoRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::machine::robot::v1::GetMotorInfoReply* Arena::CreateMaybeMessage< ::machine::robot::v1::GetMotorInfoReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::machine::robot::v1::GetMotorInfoReply >(arena);
}
template<> PROTOBUF_NOINLINE ::machine::robot::v1::MotorInfo* Arena::CreateMaybeMessage< ::machine::robot::v1::MotorInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::machine::robot::v1::MotorInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::machine::robot::v1::MotorStatus* Arena::CreateMaybeMessage< ::machine::robot::v1::MotorStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::machine::robot::v1::MotorStatus >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
