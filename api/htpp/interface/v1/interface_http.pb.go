// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// protoc-gen-go-http v2.1.0

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

type InterfaceHTTPServer interface {
	GetCurrentUser(context.Context, *GetCurrentUserRequest) (*UserReply, error)
	Login(context.Context, *LoginRequest) (*UserReply, error)
	ReadAll(context.Context, *ReadAllRequest) (*ImagesReply, error)
	ReadAllWithBinary(context.Context, *ReadAllWithBinaryRequest) (*ImagesReply, error)
	ReadAllWithBinaryAndCalArea(context.Context, *ReadAllWithBinaryAndCalAreaRequest) (*ImagesWithAreaReply, error)
	ReadOne(context.Context, *ReadOneRequest) (*ImageReply, error)
	ReadOneWithBinary(context.Context, *ReadOneWithBinaryRequest) (*ImageReply, error)
	ReadOneWithBinaryAndCalArea(context.Context, *ReadOneWithBinaryAndCalAreaRequest) (*ImageWithAreaReply, error)
	Register(context.Context, *RegisterRequest) (*UserReply, error)
	UpdateUser(context.Context, *UpdateUserRequest) (*UserReply, error)
}

func RegisterInterfaceHTTPServer(s *http.Server, srv InterfaceHTTPServer) {
	r := s.Route("/")
	r.POST("/v1/users/login", _Interface_Login0_HTTP_Handler(srv))
	r.POST("/v1/users", _Interface_Register0_HTTP_Handler(srv))
	r.GET("/v1/user/{id}", _Interface_GetCurrentUser0_HTTP_Handler(srv))
	r.PUT("/v1/user", _Interface_UpdateUser0_HTTP_Handler(srv))
	r.GET("/v1/capture/{id}", _Interface_ReadOne0_HTTP_Handler(srv))
	r.GET("/v1/capture", _Interface_ReadAll0_HTTP_Handler(srv))
	r.GET("/v1/capture/{id}/binary", _Interface_ReadOneWithBinary0_HTTP_Handler(srv))
	r.GET("/v1/capture/binary", _Interface_ReadAllWithBinary0_HTTP_Handler(srv))
	r.GET("/v1/capture/{id}/binary/area", _Interface_ReadOneWithBinaryAndCalArea0_HTTP_Handler(srv))
	r.GET("/v1/capture/binary/area", _Interface_ReadAllWithBinaryAndCalArea0_HTTP_Handler(srv))
}

func _Interface_Login0_HTTP_Handler(srv InterfaceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in LoginRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/htpp.interface.v1.Interface/Login")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Login(ctx, req.(*LoginRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UserReply)
		return ctx.Result(200, reply)
	}
}

func _Interface_Register0_HTTP_Handler(srv InterfaceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RegisterRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/htpp.interface.v1.Interface/Register")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Register(ctx, req.(*RegisterRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UserReply)
		return ctx.Result(200, reply)
	}
}

func _Interface_GetCurrentUser0_HTTP_Handler(srv InterfaceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetCurrentUserRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/htpp.interface.v1.Interface/GetCurrentUser")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetCurrentUser(ctx, req.(*GetCurrentUserRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UserReply)
		return ctx.Result(200, reply)
	}
}

func _Interface_UpdateUser0_HTTP_Handler(srv InterfaceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateUserRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/htpp.interface.v1.Interface/UpdateUser")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateUser(ctx, req.(*UpdateUserRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UserReply)
		return ctx.Result(200, reply)
	}
}

func _Interface_ReadOne0_HTTP_Handler(srv InterfaceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ReadOneRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/htpp.interface.v1.Interface/ReadOne")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ReadOne(ctx, req.(*ReadOneRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ImageReply)
		return ctx.Result(200, reply)
	}
}

func _Interface_ReadAll0_HTTP_Handler(srv InterfaceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ReadAllRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/htpp.interface.v1.Interface/ReadAll")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ReadAll(ctx, req.(*ReadAllRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ImagesReply)
		return ctx.Result(200, reply)
	}
}

func _Interface_ReadOneWithBinary0_HTTP_Handler(srv InterfaceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ReadOneWithBinaryRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/htpp.interface.v1.Interface/ReadOneWithBinary")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ReadOneWithBinary(ctx, req.(*ReadOneWithBinaryRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ImageReply)
		return ctx.Result(200, reply)
	}
}

func _Interface_ReadAllWithBinary0_HTTP_Handler(srv InterfaceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ReadAllWithBinaryRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/htpp.interface.v1.Interface/ReadAllWithBinary")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ReadAllWithBinary(ctx, req.(*ReadAllWithBinaryRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ImagesReply)
		return ctx.Result(200, reply)
	}
}

func _Interface_ReadOneWithBinaryAndCalArea0_HTTP_Handler(srv InterfaceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ReadOneWithBinaryAndCalAreaRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/htpp.interface.v1.Interface/ReadOneWithBinaryAndCalArea")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ReadOneWithBinaryAndCalArea(ctx, req.(*ReadOneWithBinaryAndCalAreaRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ImageWithAreaReply)
		return ctx.Result(200, reply)
	}
}

func _Interface_ReadAllWithBinaryAndCalArea0_HTTP_Handler(srv InterfaceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ReadAllWithBinaryAndCalAreaRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/htpp.interface.v1.Interface/ReadAllWithBinaryAndCalArea")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ReadAllWithBinaryAndCalArea(ctx, req.(*ReadAllWithBinaryAndCalAreaRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ImagesWithAreaReply)
		return ctx.Result(200, reply)
	}
}

type InterfaceHTTPClient interface {
	GetCurrentUser(ctx context.Context, req *GetCurrentUserRequest, opts ...http.CallOption) (rsp *UserReply, err error)
	Login(ctx context.Context, req *LoginRequest, opts ...http.CallOption) (rsp *UserReply, err error)
	ReadAll(ctx context.Context, req *ReadAllRequest, opts ...http.CallOption) (rsp *ImagesReply, err error)
	ReadAllWithBinary(ctx context.Context, req *ReadAllWithBinaryRequest, opts ...http.CallOption) (rsp *ImagesReply, err error)
	ReadAllWithBinaryAndCalArea(ctx context.Context, req *ReadAllWithBinaryAndCalAreaRequest, opts ...http.CallOption) (rsp *ImagesWithAreaReply, err error)
	ReadOne(ctx context.Context, req *ReadOneRequest, opts ...http.CallOption) (rsp *ImageReply, err error)
	ReadOneWithBinary(ctx context.Context, req *ReadOneWithBinaryRequest, opts ...http.CallOption) (rsp *ImageReply, err error)
	ReadOneWithBinaryAndCalArea(ctx context.Context, req *ReadOneWithBinaryAndCalAreaRequest, opts ...http.CallOption) (rsp *ImageWithAreaReply, err error)
	Register(ctx context.Context, req *RegisterRequest, opts ...http.CallOption) (rsp *UserReply, err error)
	UpdateUser(ctx context.Context, req *UpdateUserRequest, opts ...http.CallOption) (rsp *UserReply, err error)
}

type InterfaceHTTPClientImpl struct {
	cc *http.Client
}

func NewInterfaceHTTPClient(client *http.Client) InterfaceHTTPClient {
	return &InterfaceHTTPClientImpl{client}
}

func (c *InterfaceHTTPClientImpl) GetCurrentUser(ctx context.Context, in *GetCurrentUserRequest, opts ...http.CallOption) (*UserReply, error) {
	var out UserReply
	pattern := "/v1/user/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/htpp.interface.v1.Interface/GetCurrentUser"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *InterfaceHTTPClientImpl) Login(ctx context.Context, in *LoginRequest, opts ...http.CallOption) (*UserReply, error) {
	var out UserReply
	pattern := "/v1/users/login"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/htpp.interface.v1.Interface/Login"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *InterfaceHTTPClientImpl) ReadAll(ctx context.Context, in *ReadAllRequest, opts ...http.CallOption) (*ImagesReply, error) {
	var out ImagesReply
	pattern := "/v1/capture"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/htpp.interface.v1.Interface/ReadAll"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *InterfaceHTTPClientImpl) ReadAllWithBinary(ctx context.Context, in *ReadAllWithBinaryRequest, opts ...http.CallOption) (*ImagesReply, error) {
	var out ImagesReply
	pattern := "/v1/capture/binary"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/htpp.interface.v1.Interface/ReadAllWithBinary"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *InterfaceHTTPClientImpl) ReadAllWithBinaryAndCalArea(ctx context.Context, in *ReadAllWithBinaryAndCalAreaRequest, opts ...http.CallOption) (*ImagesWithAreaReply, error) {
	var out ImagesWithAreaReply
	pattern := "/v1/capture/binary/area"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/htpp.interface.v1.Interface/ReadAllWithBinaryAndCalArea"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *InterfaceHTTPClientImpl) ReadOne(ctx context.Context, in *ReadOneRequest, opts ...http.CallOption) (*ImageReply, error) {
	var out ImageReply
	pattern := "/v1/capture/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/htpp.interface.v1.Interface/ReadOne"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *InterfaceHTTPClientImpl) ReadOneWithBinary(ctx context.Context, in *ReadOneWithBinaryRequest, opts ...http.CallOption) (*ImageReply, error) {
	var out ImageReply
	pattern := "/v1/capture/{id}/binary"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/htpp.interface.v1.Interface/ReadOneWithBinary"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *InterfaceHTTPClientImpl) ReadOneWithBinaryAndCalArea(ctx context.Context, in *ReadOneWithBinaryAndCalAreaRequest, opts ...http.CallOption) (*ImageWithAreaReply, error) {
	var out ImageWithAreaReply
	pattern := "/v1/capture/{id}/binary/area"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/htpp.interface.v1.Interface/ReadOneWithBinaryAndCalArea"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *InterfaceHTTPClientImpl) Register(ctx context.Context, in *RegisterRequest, opts ...http.CallOption) (*UserReply, error) {
	var out UserReply
	pattern := "/v1/users"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/htpp.interface.v1.Interface/Register"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *InterfaceHTTPClientImpl) UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...http.CallOption) (*UserReply, error) {
	var out UserReply
	pattern := "/v1/user"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/htpp.interface.v1.Interface/UpdateUser"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
